<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Zilarte</title>
    <style>
      :root {
        color-scheme: light;
      }

      body {
        margin: 0;
        font-family: system-ui, sans-serif;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        min-height: 100vh;
        background: #f3f4f6;
        color: #111;
        padding: 1.5rem 1rem 2rem;
        box-sizing: border-box;
      }

      main {
        width: 100%;
        max-width: 1100px;
        margin: 0 auto;
      }

      .preview-panel {
        background: #fff;
        border-radius: 16px;
        padding: 1rem;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.12);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .preview-panel h2 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: #111;
      }

      .preview-media {
        position: relative;
        width: 100%;
        border-radius: 12px;
        background: #fff;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.04);
        overflow: hidden;
        aspect-ratio: 1 / 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .preview-media img,
      .preview-media canvas {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .preview-media img {
        background: #f9fafb;
        object-fit: contain;
      }

      .preview-media canvas.is-hidden {
        display: none !important;
      }

      .placeholder-content {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        color: #6b7280;
        text-align: center;
        padding: 1.5rem;
      }

      .upload-button {
        border: none;
        background: #2563eb;
        color: #fff;
        padding: 0.85rem 1.5rem;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.95rem;
        box-shadow: 0 12px 25px rgba(37, 99, 235, 0.25);
      }

      .upload-button:hover {
        background: #1d4ed8;
      }

      .back-button {
        position: absolute;
        top: 0.75rem;
        left: 0.75rem;
        border: none;
        background: rgba(15, 23, 42, 0.65);
        color: #fff;
        border-radius: 999px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        backdrop-filter: blur(4px);
        transition: opacity 0.15s ease;
      }

      .back-button:hover {
        opacity: 0.9;
      }

      .is-hidden {
        display: none !important;
      }

      .product-dependent {
        display: none;
      }

      .product-dependent.show {
        display: flex;
      }

      /* Crop overlay */
      .crop-overlay {
        position: absolute;
        box-sizing: border-box;
        border: 2px solid #ffffff;
        cursor: move;
        display: none; /* shown in original view only */
        touch-action: none;
      }

      .crop-handle {
        position: absolute;
        width: 28px;
        height: 28px;
        background: rgba(255, 255, 255, 0.6);
        border: 1px solid #ffffff;
        border-radius: 3px;
        z-index: 2;
        touch-action: none;
      }

      /* Inscribed circle inside the crop square */
      .crop-circle {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: 2px solid #ffffff;
        /* Improve visibility on any background */
        pointer-events: none; /* keep handles and drag functional */
        outline: 9999px solid rgba(0, 0, 0, 0.8); /* dim outside area */
      }

      .crop-handle.nw { top: -12px; left: -12px; cursor: nwse-resize; }
      .crop-handle.ne { top: -12px; right: -12px; cursor: nesw-resize; }
      .crop-handle.sw { bottom: -12px; left: -12px; cursor: nesw-resize; }
      .crop-handle.se { bottom: -12px; right: -12px; cursor: nwse-resize; }

      aside {
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
        padding: 1.5rem;
        box-sizing: border-box;
        background: #fff;
        border-radius: 18px;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.08);
      }

      fieldset {
        border: none;
        margin: 0 0 1rem;
        padding: 0;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.9rem;
        margin-bottom: 1rem;
      }

      input[type="range"] {
        width: 100%;
      }

      .actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        margin-top: 1.5rem;
      }

      button {
        border: none;
        background: #2563eb;
        color: #fff;
        padding: 0.6rem 1.25rem;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s ease, transform 0.15s ease;
      }

      button:hover {
        background: #1d4ed8;
      }

      button:active {
        transform: translateY(1px);
      }

      /* Disabled buttons - ensure visual state overrides */
      button[disabled],
      button:disabled {
        background: #9ca3af !important; /* gray */
        color: #fff;
        cursor: not-allowed;
        opacity: 0.7;
        box-shadow: none;
        pointer-events: none;
        transform: none;
      }

      button[disabled]:hover,
      button:disabled:hover {
        background: #9ca3af !important;
      }

      .status {
        margin-top: 1.5rem;
        font-size: 0.85rem;
        color: #666;
        line-height: 1.5;
      }

      .status strong {
        color: #111;
      }

      .instructions-panel {
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
        padding: 1.5rem;
        box-sizing: border-box;
        background: #fff;
        border-radius: 18px;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.08);
      }

      .instructions-panel .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
      }

      .instructions-panel h2 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: #111;
      }

      .copy-button {
        border: none;
        background: #111827;
        color: #fff;
        padding: 0.45rem 0.8rem;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .copy-button[disabled] {
        background: #9ca3af !important;
        cursor: not-allowed;
        opacity: 0.7;
      }

      .instructions-panel textarea {
        width: 100%;
        box-sizing: border-box;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.9rem;
        line-height: 1.4;
        padding: 0.75rem 0.9rem;
        border-radius: 10px;
        border: 1px solid #e5e7eb;
        background: #f9fafb;
        color: #111;
        resize: vertical;
        min-height: 200px;
      }
    </style>
  </head>
    <body>

    <aside>
      <fieldset>
        <label>
          Producto
          <select id="product"></select>
        </label>

        <article class="preview-panel">
          <h2 id="preview-heading">Imagen original</h2>
          <div class="preview-media">
            <img
              id="preview-image"
              alt="Vista previa de la imagen seleccionada"
              src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%239ca3af' font-size='24'%3ESin imagen%3C/text%3E%3C/svg%3E"
            />
            <div id="crop-overlay" class="crop-overlay">
              <div class="crop-circle"></div>
              <div class="crop-handle nw" data-corner="nw"></div>
              <div class="crop-handle ne" data-corner="ne"></div>
              <div class="crop-handle sw" data-corner="sw"></div>
              <div class="crop-handle se" data-corner="se"></div>
            </div>
            <canvas id="result" width="1000" height="1000" class="is-hidden"></canvas>
            <button id="back-button" class="back-button is-hidden" aria-label="Volver a seleccionar imagen">
              ←
            </button>
            <div id="placeholder-content" class="placeholder-content">
              <button id="placeholder-upload" class="upload-button" type="button">Subir imagen</button>
            </div>
          </div>
        </article>

        <label id="pegs-label" class="product-dependent">
          Clavos
          <input id="pegs" type="range" min="80" max="400" step="10" value="300" />
          <span id="pegs-value">300</span>
        </label>
        <label>
          Lineas
          <input id="lines" type="range" min="1000" max="4000" step="100" value="3000" />
          <span id="lines-value">3000</span>
        </label>
        <label id="thickness-label" class="product-dependent">
          Grosor
          <input id="thickness" type="range" min="0.01" max="0.1" step="0.001" value="0.02" />
          <span id="thickness-value">0.25</span>
        </label>
      </fieldset>

      <div class="actions">
        <button id="generate" disabled>Generar</button>
      </div>

      <div class="status">
        <div><strong>Clavos:</strong> <span id="status-pegs">-</span></div>
        <div><strong>Segmentos:</strong> <span id="status-segments">-</span></div>
        <div><strong>Error promedio:</strong> <span id="status-error">-</span></div>
      </div>
    </aside>

    <section class="instructions-panel">
      <div class="header">
        <h2>Camino del hilo para tu imagen</h2>
        <button id="copy-instructions" class="copy-button" type="button" disabled>Copiar</button>
      </div>
      <textarea
        id="instructions"
        rows="12"
        readonly
        disabled
        placeholder="Las instrucciones aparecerán aquí después de finalizar la generación..."
      ></textarea>
    </section>

    <script src="./threadingSingle.js"></script>
    <script type="text/javascript">
      let PRODUCTS = [];

      const elements = {
        product: document.getElementById("product"),
        pegs: document.getElementById("pegs"),
        lines: document.getElementById("lines"),
        thickness: document.getElementById("thickness"),
        generate: document.getElementById("generate"),
        copyInstructions: document.getElementById("copy-instructions"),
        previewImage: document.getElementById("preview-image"),
        placeholderContent: document.getElementById("placeholder-content"),
        placeholderUpload: document.getElementById("placeholder-upload"),
        backButton: document.getElementById("back-button"),
        previewHeading: document.getElementById("preview-heading"),
        cropOverlay: document.getElementById("crop-overlay"),
        canvas: document.getElementById("result"),
        statusPegs: document.getElementById("status-pegs"),
        statusSegments: document.getElementById("status-segments"),
        statusError: document.getElementById("status-error"),
        pegsValue: document.getElementById("pegs-value"),
        linesValue: document.getElementById("lines-value"),
        thicknessValue: document.getElementById("thickness-value"),
        pegsLabel: document.getElementById("pegs-label"),
        thicknessLabel: document.getElementById("thickness-label"),
      };

      // Disable actions until an image is selected
      elements.generate.disabled = true;
      /* download removed */
      elements.copyInstructions.disabled = true;

      async function loadProducts() {
        try {
          const response = await fetch("./products.json", { cache: "no-store" });
          if (!response.ok) throw new Error("No se pudieron cargar los productos");
          PRODUCTS = await response.json();

          // Populate dropdown
          elements.product.innerHTML = "";
          PRODUCTS.forEach((product, index) => {
            const option = document.createElement("option");
            option.value = index;
            option.textContent = product.name;
            elements.product.appendChild(option);
          });

          // Select first product and apply values
          if (PRODUCTS.length > 0) {
            elements.product.value = "0";
            const first = PRODUCTS[0];
            elements.pegs.value = first.pegs;
            elements.pegsValue.textContent = first.pegs;
            elements.thickness.value = first.thickness;
            elements.thicknessValue.textContent = first.thickness;
            elements.lines.value = first.lines;
            elements.linesValue.textContent = first.lines;
          }
        } catch (e) {
          console.error(e);
        }
      }

      // Handle product selection (force product values; keep pegs/thickness hidden)
      elements.product.addEventListener("change", (event) => {
        const selectedIndex = parseInt(event.target.value, 10);
        const selectedProduct = PRODUCTS[selectedIndex];
        if (!selectedProduct) return;

        elements.pegsLabel.classList.remove("show");
        elements.thicknessLabel.classList.remove("show");

        elements.pegs.value = selectedProduct.pegs;
        elements.pegsValue.textContent = selectedProduct.pegs;
        elements.thickness.value = selectedProduct.thickness;
        elements.thicknessValue.textContent = selectedProduct.thickness;
        elements.lines.value = selectedProduct.lines;
        elements.linesValue.textContent = selectedProduct.lines;
      });

      // Initialize products from external JSON
      loadProducts();

      const ctx = elements.canvas.getContext("2d");
      let currentImage = null;
      let currentThreading = null;
      let rafId = null;
      let previewObjectUrl = null;
      let instructionsFilled = false;

      function showOriginalView() {
        elements.previewHeading.textContent = "Imagen original";
        elements.previewImage.classList.remove("is-hidden");
        elements.canvas.classList.add("is-hidden");
        elements.placeholderContent.classList.toggle("is-hidden", Boolean(currentImage));
        elements.backButton.classList.add("is-hidden");
        elements.cropOverlay.style.display = currentImage ? "block" : "none";
      }

      function showResultView() {
        elements.previewHeading.textContent = "Resultado con hilos";
        elements.previewImage.classList.add("is-hidden");
        elements.canvas.classList.remove("is-hidden");
        elements.placeholderContent.classList.add("is-hidden");
        elements.backButton.classList.remove("is-hidden");
        elements.cropOverlay.style.display = "none";
      }

      showOriginalView();

      const plotter = {
        get size() {
          return { width: elements.canvas.width, height: elements.canvas.height };
        },
        drawBrokenLine(points, color, opacity, operation, thickness) {
          ThreadingSingle.applyCanvasCompositing(ctx, color, opacity, operation);
          ctx.lineWidth = thickness;
          ctx.lineCap = "round";

          for (let i = 0; i < points.length-1; i++) {
            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);
            ctx.lineTo(points[i+1].x, points[i+1].y);
            ctx.stroke();
          }
          
          ThreadingSingle.resetCanvasCompositing(ctx);
        },
        drawPoints(points, color, radius) {
          ctx.fillStyle = color;
          for (const point of points) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        },
      };

      function handleImageSelection(file) {
        if (!file) return;

        if (previewObjectUrl) {
          URL.revokeObjectURL(previewObjectUrl);
          previewObjectUrl = null;
        }

        const url = URL.createObjectURL(file);
        previewObjectUrl = url;
        const img = new Image();
        img.onload = () => {
          currentImage = img;
          elements.previewImage.src = url;
          ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
          ctx.drawImage(img, 0, 0, elements.canvas.width, elements.canvas.height);
          showOriginalView();
          elements.placeholderContent.classList.add("is-hidden");
          elements.backButton.classList.remove("is-hidden");
          // Enable generate
          elements.generate.disabled = false;
          // Initialize crop overlay
          initializeCropSelection();
          updateCropOverlay();
          // Reset instructions
          const ta = document.getElementById("instructions");
          if (ta) {
            ta.value = "";
            ta.disabled = true;
          }
          instructionsFilled = false;
        };
        img.src = url;
      }

      elements.placeholderUpload.addEventListener("click", () => {
        const tempInput = document.createElement("input");
        tempInput.type = "file";
        tempInput.accept = "image/*";
        tempInput.style.display = "none";
        document.body.appendChild(tempInput);
        tempInput.addEventListener("change", (event) => {
          const file = event.target.files[0];
          handleImageSelection(file);
          document.body.removeChild(tempInput);
        });
        tempInput.click();
      });

      elements.backButton.addEventListener("click", () => {
        currentImage = null;
        if (previewObjectUrl) {
          URL.revokeObjectURL(previewObjectUrl);
          previewObjectUrl = null;
        }
        elements.previewImage.src =
          "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%239ca3af' font-size='24'%3ESin imagen%3C/text%3E%3C/svg%3E";
        ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
        showOriginalView();
        elements.placeholderContent.classList.remove("is-hidden");
        elements.backButton.classList.add("is-hidden");
        // Disable actions again
        elements.generate.disabled = true;
        /* download removed */
        elements.copyInstructions.disabled = true;
        elements.copyInstructions.disabled = true;
        // Clear instructions
        const ta = document.getElementById("instructions");
        if (ta) {
          ta.value = "";
          ta.disabled = true;
        }
        instructionsFilled = false;
      });

      function bindRange(range, output) {
        range.addEventListener("input", () => {
          output.textContent = range.value;
        });
        output.textContent = range.value;
      }

      bindRange(elements.pegs, elements.pegsValue);
      bindRange(elements.lines, elements.linesValue);
      bindRange(elements.thickness, elements.thicknessValue);

      function updateStatus() {
        if (!currentThreading) {
          elements.statusPegs.textContent = "-";
          elements.statusSegments.textContent = "-";
          elements.statusError.textContent = "-";
          return;
        }

        elements.statusPegs.textContent = currentThreading.pegs.length;
        elements.statusSegments.textContent = currentThreading.nbSegments;
        elements.statusError.textContent = `${currentThreading.error.average} / ${currentThreading.error.meanSquare}`;
      }

      function drawLoop() {
        if (!currentThreading) return;

        const dirty = currentThreading.computeNextSegments(20);
        if (dirty) {
          ctx.fillStyle = currentThreading.parameters.invertColors ? "#000" : "#fff";
          ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
          // Uncomment to show debug view
          // currentThreading.drawDebugView(ctx);

          if (currentThreading.parameters.displayPegs) {
            currentThreading.drawPegs(plotter);
          }

          currentThreading.drawThread(plotter, 0);
          updateStatus();
          // Populate instructions once when finished
          if (!instructionsFilled && currentThreading.nbSegments >= currentThreading.parameters.nbLines) {
            const ta = document.getElementById("instructions");
            if (ta) {
              ta.value = currentThreading.instructions;
              ta.disabled = false;
              elements.copyInstructions.disabled = false;
            }
            instructionsFilled = true;
          }
        }

        rafId = requestAnimationFrame(drawLoop);
      }

      elements.generate.addEventListener("click", () => {
        if (!currentImage) {
          alert("Selecciona una imagen primero.");
          return;
        }

        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }


        showResultView();

        // Compute crop origin/size in source pixels from the overlay selection
        const crop = currentCropSelection; // {x,y,size} normalized within displayed image box
        const srcW = currentImage.naturalWidth;

        currentThreading = new ThreadingSingle(currentImage, {
          pegsCount: parseInt(elements.pegs.value, 10),
          nbLines: parseInt(elements.lines.value, 10),
          lineThickness: parseFloat(elements.thickness.value),
          cropOrigin: { x: Math.floor(crop.x * srcW), y: Math.floor(crop.y * srcW) },
          cropSize: Math.floor(crop.size * srcW),
        });

        /* download removed */
        // Reset instructions while generating
        const ta = document.getElementById("instructions");
        if (ta) {
          ta.value = "";
          ta.disabled = true;
        }
        instructionsFilled = false;
        updateStatus();
        drawLoop();
      });

      /* download removed */

      elements.copyInstructions.addEventListener("click", async () => {
        const ta = document.getElementById("instructions");
        if (!ta || !ta.value) return;
        try {
          await navigator.clipboard.writeText(ta.value);
          const original = elements.copyInstructions.textContent;
          elements.copyInstructions.textContent = "Copiado!";
          elements.copyInstructions.disabled = true;
          setTimeout(() => {
            elements.copyInstructions.textContent = original;
            elements.copyInstructions.disabled = false;
          }, 1200);
        } catch (e) {
          // Fallback if Clipboard API fails
          ta.select();
          document.execCommand("copy");
        }
      });

      // ---------- Crop overlay logic ----------
      let currentCropSelection = { x: 0.0, y: 0.0, size: 1.0 }; // normalized within displayed image box
      let dragState = null; // {type: 'move'|'resize', corner?, startX, startY, startSel}

      function getDisplayedImageBox() {
        const container = elements.previewImage.parentElement; // .preview-media
        const cw = container.clientWidth;
        const ch = container.clientHeight;
        const iw = currentImage ? currentImage.naturalWidth : 1;
        const ih = currentImage ? currentImage.naturalHeight : 1;
        const scale = Math.min(cw / iw, ch / ih);
        const w = iw * scale;
        const h = ih * scale;
        const left = (cw - w) / 2;
        const top = (ch - h) / 2;
        return { left, top, width: w, height: h };
      }

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      function updateCropOverlay() {
        const box = getDisplayedImageBox();
        const x = box.left + currentCropSelection.x * box.width;
        const y = box.top + currentCropSelection.y * box.width;
        const sizePx = currentCropSelection.size * box.width;

        const el = elements.cropOverlay;
        el.style.display = currentImage ? "block" : "none";
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        el.style.width = `${sizePx}px`;
        el.style.height = `${sizePx}px`;
      }

      function startDrag(e, type, corner) {
        e.preventDefault();
        const rect = elements.previewImage.parentElement.getBoundingClientRect();
        const startX = e.clientX;
        const startY = e.clientY;
        dragState = {
          type,
          corner,
          startX,
          startY,
          rect,
          startSel: { ...currentCropSelection },
        };
        window.addEventListener("pointermove", onDragMove);
        window.addEventListener("pointerup", endDrag, { once: true });
      }

      function onDragMove(e) {
        if (!dragState) return;
        const box = getDisplayedImageBox();
        const heightToWidthRatio = box.height / box.width;
        const dx = (e.clientX - dragState.startX) / box.width;
        const dy = (e.clientY - dragState.startY) / box.height;
        let { x, y, size } = dragState.startSel;
        const maxSize = Math.min(1, heightToWidthRatio);

        if (dragState.type === "move") {
          x = clamp(x + dx, 0, maxSize - size);
          y = clamp(y + dy, 0, heightToWidthRatio - size);
        } else if (dragState.type === "resize") {
          const x0 = x;
          const y0 = y;
          const s0 = size;

          if (dragState.corner === "nw") {
            // Anchor at bottom-right (x0+s0, y0+s0)
            const ax = x0 + s0;
            const ay = y0 + s0;
            const mx = clamp(x0 + dx, 0, ax); // normalized
            const my = clamp(y0 + dy, 0, ay);
            let s = Math.max(ax - mx, ay - my);
            size = clamp(s, 0.05, Math.min(ax, ay));
            x = ax - size;
            y = ay - size;
          } else if (dragState.corner === "ne") {
            // Anchor at bottom-left (x0, y0+s0)
            const ax = x0;
            const ay = y0 + s0;
            const mx = clamp(x0 + s0 + dx, ax, 1);
            const my = clamp(y0 + dy, 0, ay);
            const s = Math.max(mx - ax, ay - my);
            size = clamp(s, 0.05, Math.min(1.0 - ax, ay));
            y = ay - size;
          } else if (dragState.corner === "sw") {
            // Anchor at top-right (x0+s0, y0)
            const ax = x0 + s0;
            const ay = y0;
            const mx = clamp(x0 + dx, 0, ax);
            const my = clamp(y0 + s0 + dy, ay, heightToWidthRatio);
            const s = Math.max(ax - mx, my - ay);
            size = clamp(s, 0.05, Math.min(ax, heightToWidthRatio - ay));
            x = ax - size;
          } else if (dragState.corner === "se") {
            // Anchor at top-left (x0, y0)
            const ax = x0;
            const ay = y0;
            const mx = clamp(x0 + s0 + dx, ax, 1);
            const my = clamp(y0 + s0 + dy, ay, heightToWidthRatio);
            const s = Math.max(mx - ax, my - ay);
            size = clamp(s, 0.05, Math.min(1.0 - ax, heightToWidthRatio - ay));
          }
        }

        currentCropSelection = { x, y, size };
        updateCropOverlay();
      }

      function endDrag() {
        window.removeEventListener("pointermove", onDragMove);
        dragState = null;
      }

      function initializeCropSelection() {
        // Make the square as large as possible without overflowing the displayed image
        const box = getDisplayedImageBox();
        const height = box.height / box.width;
        const size = Math.min(1, height); // normalized to displayed width
        const x = 0.5 - size / 2;
        const y = height / 2 - size / 2;
        currentCropSelection = { x: Math.max(0, x), y: Math.max(0, y), size };
        const overlay = elements.cropOverlay;
        overlay.onpointerdown = (e) => startDrag(e, "move");
        overlay.querySelectorAll(".crop-handle").forEach((h) => {
          h.onpointerdown = (e) => {
            e.stopPropagation(); // prevent overlay move handler
            startDrag(e, "resize", h.getAttribute("data-corner"));
          };
        });
        updateCropOverlay();
      }

      window.addEventListener("resize", () => {
        if (currentImage) updateCropOverlay();
      });
    </script>
  </body>
</html>

